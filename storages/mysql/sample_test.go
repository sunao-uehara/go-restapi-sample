package mysql

import (
	"encoding/json"
	"errors"
	"reflect"
	"testing"

	"github.com/golang/mock/gomock"
	//"github.com/stretchr/testify/require"
	mock_mysql "github.com/sunao-uehara/go-restapi-sample/storages/mysql/mock"
)

var testSample1 = &SampleData{
	ID:     int64(1),
	Foo:    "var",
	IntVal: int64(1001),
}

var testSample2 = &SampleData{
	ID:     int64(2),
	Foo:    "var",
	IntVal: int64(1002),
}

type mockSample struct {
}

func NewMockSample() Sample {
	return &mockSample{}
}

func (msc *mockSample) CreateSample(sample *SampleData) (int64, error) {
	if sample.ID != 0 {
		return sample.ID, nil
	}
	return 1, nil
}

func (msc *mockSample) GetSample(id int64) (*SampleData, error) {
	return testSample1, nil
}

func (msc *mockSample) GetManySample() ([]*SampleData, error) {
	return []*SampleData{
		testSample1,
		testSample2,
	}, nil
}

func (msc *mockSample) UpdateSample(id int64, sample *SampleData) (int64, error) {
	return 1, nil
}

// use custom mock
func TestCreateSample2(t *testing.T) {
	sc := NewMockSample()
	id, err := sc.CreateSample(testSample1)
	if err != nil {
		t.Errorf("test failed, error: %v", err)
	}
	if id != 1 {
		t.Errorf("test failed, got: %v, want: 1", id)
	}
}

// use mock generated by mockgen
func TestCreateSample3(t *testing.T) {

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	sample := mock_mysql.NewMockSample(ctrl)

}

func TestCreateSample(t *testing.T) {
	type in struct {
		Sample *SampleData
	}
	type out struct {
		Expected int64
		Error    error
	}
	type testCase struct {
		Scenario string
		In       *in
		Out      *out
	}

	testCases := []testCase{
		{
			"success case 1",
			&in{
				Sample: &SampleData{
					Foo:    "var",
					IntVal: int64(1),
				},
			},
			&out{
				Expected: int64(1),
			},
		},
		{
			"success case 2",
			&in{
				Sample: &SampleData{
					Foo:    "var 2",
					IntVal: int64(2),
				},
			},
			&out{
				Expected: int64(2),
			},
		},
		{
			"failure case, invalid data sent",
			&in{
				Sample: nil,
			},
			&out{
				Expected: 0,
				Error:    errors.New("invalid data sent"),
			},
		},
	}

	createTestTable("sample")
	for _, testCase := range testCases {
		in := testCase.In
		out := testCase.Out
		sc := NewSample(testDB)
		id, err := sc.CreateSample(in.Sample)
		if testCase.Out.Expected != id {
			t.Errorf("test failed, got: %v, want: %v", id, testCase.Out.Expected)
		}

		switch {
		case err != nil && out.Error == nil:
			t.Errorf("expected non error, but some error occurred, %s", err.Error())
		case err == nil && out.Error != nil:
			t.Errorf("expected error %s, but results: no error", out.Error.Error())
		case err != nil && out.Error != nil:
			// fmt.Println(err)
		}

	}
	deleteTestTable("sample")
}

func TestGetSample(t *testing.T) {
	testData := &SampleData{
		ID:     int64(1),
		Foo:    "var",
		IntVal: int64(100),
	}

	type in struct {
		ID int64
	}
	type out struct {
		Expected *SampleData
		Error    error
	}
	type testCase struct {
		Scenario string
		In       *in
		Out      *out
	}

	testCases := []testCase{
		{
			"success case",
			&in{
				ID: int64(1),
			},
			&out{
				Expected: testData,
			},
		},
		{
			"failure case, data not exits",
			&in{
				ID: int64(2),
			},
			&out{
				Expected: nil,
				Error:    errors.New("sql: no rows in result set"),
			},
		},
	}

	createTestTable("sample")
	sc := NewSample(testDB)
	sc.CreateSample(testData)
	for _, testCase := range testCases {
		in := testCase.In
		out := testCase.Out
		got, err := sc.GetSample(in.ID)
		if !reflect.DeepEqual(out.Expected, got) {
			t.Errorf("test failed, got: %v, want: %v", got, testCase.Out.Expected)
		}

		switch {
		case err != nil && out.Error == nil:
			t.Errorf("expected non error, but some error occurred, %s", err.Error())
		case err == nil && out.Error != nil:
			t.Errorf("expected error %s, but results: no error", out.Error.Error())
		case err != nil && out.Error != nil:
			// fmt.Println(err)
		}
	}
	deleteTestTable("sample")
}

func TestGetManySample(t *testing.T) {
	testDataList := []*SampleData{
		{
			ID:     int64(1),
			Foo:    "var",
			IntVal: int64(101),
		},
		{
			ID:     int64(2),
			Foo:    "var2",
			IntVal: int64(102),
		},
	}

	type out struct {
		Expected []*SampleData
		Error    error
	}
	type testCase struct {
		Scenario string
		Out      *out
	}

	testCases := []testCase{
		{
			"success case",
			&out{
				Expected: testDataList,
			},
		},
	}

	createTestTable("sample")
	sc := NewSample(testDB)
	for _, d := range testDataList {
		sc.CreateSample(d)
	}
	for _, testCase := range testCases {
		out := testCase.Out
		got, _ := sc.GetManySample()
		if !reflect.DeepEqual(out.Expected, got) {
			gotStr, _ := json.Marshal(got)
			expectedStr, _ := json.Marshal(out.Expected)
			t.Errorf("test failed, got: %v, want: %v", string(gotStr), string(expectedStr))
		}
	}
	deleteTestTable("sample")
}

func TestUpdateSample(t *testing.T) {
	testData := &SampleData{
		ID:     int64(1),
		Foo:    "var",
		IntVal: int64(100),
	}

	type in struct {
		ID   int64
		Data *SampleData
	}
	type out struct {
		RowsAffected int64
		Expected     *SampleData
		Error        error
	}
	type testCase struct {
		Scenario string
		In       *in
		Out      *out
	}

	testCases := []testCase{
		{
			"success case, update one field",
			&in{
				ID: int64(1),
				Data: &SampleData{
					Foo: "var mod 1",
				},
			},
			&out{
				RowsAffected: int64(1),
				Expected: &SampleData{
					ID:     int64(1),
					Foo:    "var mod 1",
					IntVal: int64(100),
				},
			},
		},
		{
			"success case, update all field",
			&in{
				ID: int64(1),
				Data: &SampleData{
					Foo:    "var mod 2",
					IntVal: int64(101),
				},
			},
			&out{
				RowsAffected: int64(1),
				Expected: &SampleData{
					ID:     int64(1),
					Foo:    "var mod 2",
					IntVal: int64(101),
				},
			},
		},
		{
			"success case, update as same record",
			&in{
				ID: int64(1),
				Data: &SampleData{
					Foo:    "var mod 2",
					IntVal: int64(101),
				},
			},
			&out{
				RowsAffected: int64(0),
				Expected: &SampleData{
					ID:     int64(1),
					Foo:    "var mod 2",
					IntVal: int64(101),
				},
			},
		},
		{
			"success case, data not exits",
			&in{
				ID: int64(2),
				Data: &SampleData{
					Foo:    "var mod 3",
					IntVal: int64(102),
				},
			},
			&out{
				RowsAffected: int64(0),
				Expected:     nil,
			},
		},
		{
			"failure case, invalid data sent",
			&in{
				ID:   int64(1),
				Data: nil,
			},
			&out{
				RowsAffected: int64(0),
				// the original data shouldn't be changed
				Expected: &SampleData{
					ID:     int64(1),
					Foo:    "var mod 2",
					IntVal: int64(101),
				},
				Error: errors.New("invalid data"),
			},
		},
	}

	createTestTable("sample")
	sc := NewSample(testDB)
	sc.CreateSample(testData)
	for _, testCase := range testCases {
		in := testCase.In
		out := testCase.Out
		got, err := sc.UpdateSample(in.ID, in.Data)
		if out.RowsAffected != got {
			t.Errorf("test failed, got: %v, want: %v", got, testCase.Out.RowsAffected)
		}

		updated, _ := sc.GetSample(in.ID)
		if !reflect.DeepEqual(out.Expected, updated) {
			t.Errorf("test failed, got: %v, want: %v", updated, testCase.Out.Expected)
		}

		switch {
		case err != nil && out.Error == nil:
			t.Errorf("expected non error, but some error occurred, %s", err.Error())
		case err == nil && out.Error != nil:
			t.Errorf("expected error %s, but results: no error", out.Error.Error())
		case err != nil && out.Error != nil:
			// fmt.Println(err)
		}
	}
	deleteTestTable("sample")
}
